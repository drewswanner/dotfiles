"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const leb_1 = require("leb");
const bqrs_schema_1 = require("./bqrs-schema");
/**
 * bqrs-parse.ts
 * -------
 *
 * Parsing Binary Query Result Set files.
 * See [[https://git.semmle.com/Semmle/code/tree/master/queryserver-client/src/com/semmle/api/result/BinaryQueryResultSets.java]].
 */
const RESULT_SET_VERSION = 1;
const RESULT_SETS_VERSION = 2;
async function parseResultColumnType(d) {
    const t = await d.readASCIIChar();
    if (t === 'e') {
        const primitiveType = (await d.readASCIIChar());
        const hasLabel = (await d.readByte()) !== 0;
        const locationStyle = await d.readByte();
        return { type: 'e', locationStyle, hasLabel, primitiveType };
    }
    else {
        return { type: t };
    }
}
async function parseColumnSchema(d) {
    const numColumns = await d.readLEB128UInt32();
    const rv = [];
    for (let i = 0; i < numColumns; i++) {
        const name = await readLengthPrefixedString(d);
        const type = await parseResultColumnType(d);
        rv.push({ name, type });
    }
    return rv;
}
function getTrueStringLength(encodedLength) {
    const stringLength = encodedLength - 1;
    if (stringLength === -1) {
        // XXX why is this a possibility? Does a '(-1)-length' string
        // (i.e. a single 0x00 byte) mean something different from a
        // 0-length string? (i.e. a single 0x01 byte)
        return 0;
    }
    else {
        return stringLength;
    }
}
class StringPool {
    constructor(buffer) {
        this.buffer = buffer;
    }
    getString(offset) {
        //TODO: Memoize?
        const { value: encodedStringLength, nextIndex } = leb_1.decodeUInt32(this.buffer, offset);
        const stringLength = getTrueStringLength(encodedStringLength);
        const value = this.buffer.toString('utf8', nextIndex, nextIndex + stringLength);
        return value;
    }
}
exports.StringPool = StringPool;
async function parseResultSetsHeader(d) {
    const version = await d.readLEB128UInt32();
    if (version !== RESULT_SETS_VERSION) {
        throw new Error(`Mismatched binary query results version. Got '${version}', but expected '${RESULT_SETS_VERSION}'.`);
    }
    const resultSetCount = await d.readLEB128UInt32();
    const stringPoolSize = await d.readLEB128UInt32();
    return {
        version: version,
        stringPoolSize: stringPoolSize,
        resultSetCount: resultSetCount
    };
}
exports.parseResultSetsHeader = parseResultSetsHeader;
async function readLengthPrefixedString(d) {
    const encodedLength = await d.readLEB128UInt32();
    const stringLength = getTrueStringLength(encodedLength);
    return await d.readUTF8String(stringLength);
}
async function parseResultSetSchema(d) {
    const version = await d.readLEB128UInt32();
    if (version !== RESULT_SET_VERSION) {
        throw new Error(`Mismatched binary query result version. Got '${version}', but expected '${RESULT_SET_VERSION}'.`);
    }
    const name = await readLengthPrefixedString(d);
    const tupleCount = await d.readLEB128UInt32();
    const columns = await parseColumnSchema(d);
    return {
        version: version,
        name: name,
        tupleCount: tupleCount,
        columns: columns
    };
}
exports.parseResultSetSchema = parseResultSetSchema;
async function parseString(d, pool) {
    const stringOffset = await d.readLEB128UInt32();
    const value = pool.getString(stringOffset);
    return value;
}
async function parseLocation(d, t, pool) {
    switch (t) {
        case bqrs_schema_1.LocationStyle.None: return undefined;
        case bqrs_schema_1.LocationStyle.String: return { t, loc: await parseString(d, pool) };
        case bqrs_schema_1.LocationStyle.FivePart: {
            const file = await parseString(d, pool);
            const lineStart = await d.readLEB128UInt32();
            const colStart = await d.readLEB128UInt32();
            const lineEnd = await d.readLEB128UInt32();
            const colEnd = await d.readLEB128UInt32();
            return { t, file, lineStart, colStart, lineEnd, colEnd };
        }
        case bqrs_schema_1.LocationStyle.WholeFile:
            throw new Error('Whole-file locations should appear as string locations in BQRS files.');
    }
    throw new Error(`Unknown Location Style ${t}`);
}
async function parsePrimitiveColumn(d, type, pool) {
    switch (type) {
        case 's': return await parseString(d, pool);
        case 'b': return await d.readByte() !== 0;
        case 'i': {
            const unsignedValue = await d.readLEB128UInt32();
            // `int` column values are encoded as 32-bit unsigned LEB128, but are really 32-bit two's
            // complement signed integers. The easiest way to reinterpret from an unsigned int32 to a
            // signed int32 in JavaScript is to use a bitwise operator, which does this coercion on its
            // operands automatically.
            return unsignedValue | 0;
        }
        case 'f': return await d.readDoubleLE();
        case 'd': return await d.readDate();
        case 'u': return await parseString(d, pool);
        default: throw new Error(`Unknown primitive column type '${type}'.`);
    }
}
async function parseColumn(d, t, pool) {
    if (t.type === 'e') {
        let primitive = await parsePrimitiveColumn(d, t.primitiveType, pool);
        const label = t.hasLabel ? await parseString(d, pool) : undefined;
        const loc = await parseLocation(d, t.locationStyle, pool);
        return {
            id: primitive,
            label: label,
            location: loc
        };
    }
    else {
        return parsePrimitiveColumn(d, t.type, pool);
    }
}
exports.parseColumn = parseColumn;
function readTuples(d, schema, stringPool) {
    return __asyncGenerator(this, arguments, function* readTuples_1() {
        const { tupleCount, columns } = schema;
        for (let rowIndex = 0; rowIndex < tupleCount; rowIndex++) {
            const tuple = Array(columns.length);
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                tuple[columnIndex] = yield __await(parseColumn(d, columns[columnIndex].type, stringPool));
            }
            yield yield __await(tuple);
        }
    });
}
exports.readTuples = readTuples;
async function parseTuples(d, schema, stringPool, tupleParser) {
    const { tupleCount, columns } = schema;
    // Create a single temporary tuple to hold the values we read from each row. Fill it with
    // zero values initially so that we don't have to type it as `TupleValue | undefined`.
    const tempTuple = Array(columns.length).fill(0);
    for (let rowIndex = 0; rowIndex < tupleCount; rowIndex++) {
        for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
            tempTuple[columnIndex] = await parseColumn(d, columns[columnIndex].type, stringPool);
        }
        tupleParser(tempTuple);
    }
}
exports.parseTuples = parseTuples;

//# sourceMappingURL=bqrs-parse.js.map
