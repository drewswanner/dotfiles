"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const bqrs_schema_1 = require("./bqrs-schema");
var QLOption;
(function (QLOption) {
    QLOption["Required"] = "required";
    QLOption["Optional"] = "optional";
    QLOption["Forbidden"] = "forbidden";
})(QLOption = exports.QLOption || (exports.QLOption = {}));
/**
 * An attribute that binds the target property to a result column representing a QL element.
 * @param index Index of the column to be bound.
 * @param options Binding options.
 */
function qlElement(index, options = {}) {
    return (proto, key) => {
        column(proto, {
            key: key,
            index: index,
            type: 'e',
            options: {
                label: options.label ? options.label : QLOption.Required,
                location: options.location ? options.location : QLOption.Required
            }
        });
    };
}
exports.qlElement = qlElement;
/**
 * An attribute that binds the target property to a result column containing a QL string.
 * @param index Index of the column to be bound.
 */
function qlString(index) {
    return (proto, key) => {
        column(proto, {
            key: key,
            index: index,
            type: 's'
        });
    };
}
exports.qlString = qlString;
/**
 * An attribute that binds the target property to a set of result columns. The individual
 * columns are bound to properties of the underlying type of the target property.
 * @param index Index of the first column to be bound.
 * @param type The type of the property.
 */
function qlTuple(index, type) {
    return (proto, key) => {
        column(proto, {
            key: key,
            index: index,
            type: type
        });
    };
}
exports.qlTuple = qlTuple;
function isElement(property) {
    return property.type === 'e';
}
const columnPropertiesSymbol = Symbol('columnProperties');
function column(proto, property) {
    let columnProperties = Reflect.getMetadata(columnPropertiesSymbol, proto);
    if (columnProperties === undefined) {
        columnProperties = [];
        Reflect.defineMetadata(columnPropertiesSymbol, columnProperties, proto);
    }
    columnProperties.push(property);
}
const tablePropertiesSymbol = Symbol('tableProperties');
/**
 * An attribute that binds the target property to the contents of a result table.
 * @param rowType The type representing a single row in the bound table. The type of the target
 *   property must be an array of this type.
 * @param options Binding options.
 */
function qlTable(rowType, options) {
    return (proto, key) => {
        const realOptions = options || {};
        let names;
        if (realOptions.name === undefined) {
            names = [key.toString()];
        }
        else if (typeof realOptions.name === 'string') {
            names = [realOptions.name];
        }
        else {
            names = realOptions.name;
        }
        let tableProperties = Reflect.getMetadata(tablePropertiesSymbol, proto);
        if (tableProperties === undefined) {
            tableProperties = [];
            Reflect.defineMetadata(tablePropertiesSymbol, tableProperties, proto);
        }
        tableProperties.push({
            key: key,
            tableNames: names,
            rowType: rowType
        });
    };
}
exports.qlTable = qlTable;
class CustomResultSet {
    constructor(reader, tupleParser) {
        this.reader = reader;
        this.tupleParser = tupleParser;
    }
    readTuples() {
        return __asyncGenerator(this, arguments, function* readTuples_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.reader.readTuples()), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const tuple = _c.value;
                    yield yield __await(this.tupleParser(tuple));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
}
exports.CustomResultSet = CustomResultSet;
class CustomResultSetBinder {
    constructor(rowType, schema) {
        this.rowType = rowType;
        this.schema = schema;
        this.boundColumns = Array(schema.columns.length).fill(false);
    }
    static bind(reader, rowType) {
        const binder = new CustomResultSetBinder(rowType, reader.schema);
        const tupleParser = binder.bindRoot();
        return new CustomResultSet(reader, tupleParser);
    }
    bindRoot() {
        const { action } = this.bindObject(this.rowType, 0, true);
        const unboundColumnIndex = this.boundColumns.indexOf(false);
        if (unboundColumnIndex >= 0) {
            throw new Error(`Column '${this.schema.name}[${unboundColumnIndex}]' is not bound to a property.`);
        }
        return tuple => {
            let result = new this.rowType;
            action(tuple, result);
            return result;
        };
    }
    checkElementProperty(index, propertyName, hasProperty, expectsProperty) {
        switch (expectsProperty) {
            case QLOption.Required:
                if (!hasProperty) {
                    throw new Error(`Element column '${this.schema.name}[${index}]' does not have the required '${propertyName}' property.`);
                }
                break;
            case QLOption.Forbidden:
                if (!hasProperty) {
                    throw new Error(`Element column '${this.schema.name}[${index}]' has unexpected '${propertyName}' property.`);
                }
                break;
            case QLOption.Optional:
                break;
        }
    }
    bindObject(type, startIndex, isRoot) {
        const columnProperties = Reflect.getMetadata(columnPropertiesSymbol, type.prototype);
        if (columnProperties === undefined) {
            throw new Error(`Type '${type.toString()}' does not have any properties decorated with '@column'.`);
        }
        const actions = [];
        let restProperty = undefined;
        let lastColumn = startIndex;
        for (const property of columnProperties) {
            if (typeof property.index === 'object') {
                if (!isRoot) {
                    throw new Error(`Type '${type.toString()}' has a property bound to '...', but is not the root type.`);
                }
                if (restProperty !== undefined) {
                    throw new Error(`Type '${type.toString()}' has multiple properties bound to '...'.`);
                }
                restProperty = property;
            }
            else {
                const index = property.index + startIndex;
                const { action, lastColumn: lastChildColumn } = this.bindColumn(index, type, property, property.key);
                actions.push(action);
                lastColumn = Math.max(lastColumn, lastChildColumn);
            }
        }
        if (restProperty !== undefined) {
            const startIndex = restProperty.index.startColumn;
            let index = startIndex;
            let elementIndex = 0;
            const elementActions = [];
            while (index < this.schema.columns.length) {
                const { action, lastColumn: lastChildColumn } = this.bindColumn(index, type, restProperty, elementIndex);
                elementActions.push(action);
                index = lastChildColumn + 1;
                elementIndex++;
            }
            const key = restProperty.key;
            actions.push((src, dest) => {
                const destArray = Array(elementActions.length);
                elementActions.forEach(action => action(src, destArray));
                dest[key] = destArray;
            });
        }
        return {
            action: (src, dest) => actions.forEach(action => action(src, dest)),
            lastColumn: lastColumn
        };
    }
    bindColumn(index, type, property, key) {
        if ((index < 0) || (index >= this.schema.columns.length)) {
            throw new Error(`No matching column '${index}' found for property '${type.toString()}.${property.key.toString()}' when binding root type '${this.rowType.toString()}'.`);
        }
        if (typeof property.type === 'string') {
            // This property is bound to a single column
            return {
                action: this.bindSingleColumn(index, property, type, key),
                lastColumn: index
            };
        }
        else {
            // This property is a tuple that has properties that are bound to columns.
            const propertyType = property.type;
            const { action: objectParser, lastColumn: lastChildColumn } = this.bindObject(propertyType, index, false);
            return {
                action: (src, dest) => {
                    const destObject = new propertyType;
                    objectParser(src, destObject);
                    dest[key] = destObject;
                },
                lastColumn: lastChildColumn
            };
        }
    }
    bindSingleColumn(index, property, type, key) {
        if (this.boundColumns[index]) {
            throw new Error(`Column '${this.schema.name}[${index}]' is bound to multiple columns in root type '${this.rowType.toString()}'.`);
        }
        const column = this.schema.columns[index];
        if (column.type.type !== property.type) {
            throw new Error(`Column '${this.schema.name}[${index}]' has type '${column.type.type}', but property '${type.toString()}.${property.key.toString()}' expected type '${property.type}'.`);
        }
        this.boundColumns[index] = true;
        if (isElement(property) && (column.type.type === 'e')) {
            const hasLabel = column.type.hasLabel;
            this.checkElementProperty(index, 'label', hasLabel, property.options.label);
            const hasLocation = column.type.locationStyle !== bqrs_schema_1.LocationStyle.None;
            this.checkElementProperty(index, 'location', hasLocation, property.options.location);
            return (src, dest) => {
                const srcElement = src[index];
                const destElement = {
                    id: srcElement.id
                };
                if (hasLabel) {
                    destElement.label = srcElement.label;
                }
                if (hasLocation) {
                    destElement.location = srcElement.location;
                }
                dest[key] = destElement;
            };
        }
        else {
            return (src, dest) => {
                dest[key] = src[index];
            };
        }
    }
}
function createCustomResultSets(reader, type) {
    const tableProperties = Reflect.getMetadata(tablePropertiesSymbol, type.prototype);
    if (tableProperties === undefined) {
        throw new Error(`Type '${type.toString()}' does not have any properties decorated with '@table'.`);
    }
    const customResultSets = {};
    const boundProperties = new Set();
    for (const resultSet of reader.resultSets) {
        const tableProperty = findPropertyForTable(resultSet.schema, tableProperties);
        if (tableProperty === undefined) {
            throw new Error(`No matching property found for result set '${resultSet.schema.name}'.`);
        }
        if (boundProperties.has(tableProperty.key)) {
            throw new Error(`Multiple result sets bound to property '${tableProperty.key.toString()}'.`);
        }
        boundProperties.add(tableProperty.key);
        customResultSets[tableProperty.key] = CustomResultSetBinder.bind(resultSet, tableProperty.rowType);
    }
    for (const tableProperty of tableProperties) {
        if (!boundProperties.has(tableProperty.key)) {
            throw new Error(`No matching table found for property '${tableProperty.key.toString()}'.`);
        }
    }
    return customResultSets;
}
exports.createCustomResultSets = createCustomResultSets;
function findPropertyForTable(resultSet, tableProperties) {
    const tableName = resultSet.name === '#select' ? 'select' : resultSet.name;
    return tableProperties.find(tableProperty => tableProperty.tableNames.find(name => name === tableName));
}

//# sourceMappingURL=bqrs-custom.js.map
